<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Waveform Animation Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5rem;
            font-weight: bold;
        }

        .upload-section {
            background: #f8f9ff;
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-section:hover {
            background: #f0f2ff;
            border-color: #764ba2;
            transform: translateY(-2px);
        }

        .upload-section.dragover {
            background: #e8ecff;
            border-color: #5a67d8;
        }

        .file-input {
            display: none;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            color: #667eea;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .color-input {
            height: 45px;
            border: none;
            cursor: pointer;
        }

        .canvas-container {
            background: #000;
            border-radius: 15px;
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .playback-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .export-section {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status {
            margin-top: 10px;
            font-weight: 600;
            color: #4a5568;
        }

        .waveform-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
            color: #6b7280;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .playback-controls {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Audio Waveform Animation Creator</h1>
        
        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">üéµ</div>
            <h3>‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á</h3>
            <p>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</p>
            <p style="font-size: 12px; color: #666; margin-top: 10px;">‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö: MP3, WAV, OGG, M4A</p>
            <input type="file" id="audioFile" class="file-input" accept="audio/*">
        </div>

        <div class="controls">
            <div class="control-group">
                <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á Canvas:</label>
                <input type="number" id="canvasWidth" value="800" min="400" max="1920">
            </div>
            <div class="control-group">
                <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á Canvas:</label>
                <input type="number" id="canvasHeight" value="200" min="100" max="600">
            </div>
            <div class="control-group">
                <label>‡∏™‡∏µ Waveform:</label>
                <input type="color" id="waveformColor" value="#00ff88" class="color-input">
            </div>
            <div class="control-group">
                <label>‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á:</label>
                <input type="color" id="backgroundColor" value="#000000" class="color-input">
            </div>
            <div class="control-group">
                <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á Bar:</label>
                <input type="range" id="barWidth" min="2" max="20" value="6">
                <span id="barWidthValue">6</span>
            </div>
            <div class="control-group">
                <label>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Bar:</label>
                <input type="range" id="barCount" min="5" max="50" value="15">
                <span id="barCountValue">15</span>
            </div>
            <div class="control-group">
                <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß Animation:</label>
                <input type="range" id="animationSpeed" min="0.5" max="3" step="0.1" value="1">
                <span id="animationSpeedValue">1.0</span>
            </div>
            <div class="control-group">
                <label>‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á Bar:</label>
                <input type="range" id="barSpacing" min="1" max="10" value="3">
                <span id="barSpacingValue">3</span>
            </div>
            <div class="control-group">
                <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ß‡∏ï‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á:</label>
                <input type="range" id="sensitivity" min="0.5" max="3" step="0.1" value="1">
                <span id="sensitivityValue">1.0</span>
            </div>
        </div>

        <div class="canvas-container" style="display: none;" id="canvasContainer">
            <div class="waveform-info" id="waveformInfo">
                <span>‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤: <span id="duration">0:00</span></span>
                <span>‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á: <span id="currentTime">0:00</span></span>
            </div>
            <canvas id="waveformCanvas"></canvas>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="playback-controls">
            <button class="btn btn-primary" id="playBtn" disabled>‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô</button>
            <button class="btn btn-secondary" id="pauseBtn" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
            <button class="btn btn-secondary" id="stopBtn" disabled>‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
            <button class="btn btn-primary" id="generateBtn" disabled>üé¨ ‡∏™‡∏£‡πâ‡∏≤‡∏á Animation</button>
        </div>

        <div class="export-section" id="exportSection" style="display: none;">
            <h3>‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Animation</h3>
            <div class="controls" style="margin: 20px 0;">
                <div class="control-group">
                    <label>‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å:</label>
                    <select id="exportFormat">
                        <option value="webm">WebM Video</option>
                        <option value="gif">GIF Animation</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û (FPS):</label>
                    <select id="exportFPS">
                        <option value="30">30 FPS</option>
                        <option value="60">60 FPS (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)</option>
                        <option value="24">24 FPS (‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î)</option>
                    </select>
                </div>
            </div>
            <button class="btn btn-primary" id="exportBtn" disabled>üì• ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</button>
            <div class="progress-bar" id="exportProgress" style="display: none;">
                <div class="progress-fill" id="exportProgressFill"></div>
            </div>
            <div class="status" id="exportStatus"></div>
        </div>
    </div>

    <script>
        class WaveformAnimator {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.source = null;
                this.analyser = null;
                this.canvas = document.getElementById('waveformCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isPlaying = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.animationId = null;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.animationTime = 0;
                this.previousBarHeights = [];
                
                this.setupEventListeners();
                this.setupCanvas();
            }

            setupEventListeners() {
                const uploadSection = document.getElementById('uploadSection');
                const fileInput = document.getElementById('audioFile');

                // Upload events
                uploadSection.addEventListener('click', () => fileInput.click());
                uploadSection.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadSection.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadSection.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Control events
                document.getElementById('playBtn').addEventListener('click', this.play.bind(this));
                document.getElementById('pauseBtn').addEventListener('click', this.pause.bind(this));
                document.getElementById('stopBtn').addEventListener('click', this.stop.bind(this));
                document.getElementById('generateBtn').addEventListener('click', this.generateAnimation.bind(this));
                document.getElementById('exportBtn').addEventListener('click', this.exportAnimation.bind(this));

                // Canvas size events
                document.getElementById('canvasWidth').addEventListener('input', this.setupCanvas.bind(this));
                document.getElementById('canvasHeight').addEventListener('input', this.setupCanvas.bind(this));

                // Slider events
                const barWidthSlider = document.getElementById('barWidth');
                const barCountSlider = document.getElementById('barCount');
                const barSpacingSlider = document.getElementById('barSpacing');
                const animationSpeedSlider = document.getElementById('animationSpeed');
                const smoothnessSlider = document.getElementById('smoothness');
                const sensitivitySlider = document.getElementById('sensitivity');

                if (barWidthSlider) {
                    barWidthSlider.addEventListener('input', (e) => {
                        document.getElementById('barWidthValue').textContent = e.target.value;
                    });
                }
                if (barCountSlider) {
                    barCountSlider.addEventListener('input', (e) => {
                        document.getElementById('barCountValue').textContent = e.target.value;
                    });
                }
                if (barSpacingSlider) {
                    barSpacingSlider.addEventListener('input', (e) => {
                        document.getElementById('barSpacingValue').textContent = e.target.value;
                    });
                }
                if (animationSpeedSlider) {
                    animationSpeedSlider.addEventListener('input', (e) => {
                        document.getElementById('animationSpeedValue').textContent = parseFloat(e.target.value).toFixed(1);
                    });
                }
                if (smoothnessSlider) {
                    smoothnessSlider.addEventListener('input', (e) => {
                        document.getElementById('smoothnessValue').textContent = parseFloat(e.target.value).toFixed(1);
                    });
                }
                if (sensitivitySlider) {
                    sensitivitySlider.addEventListener('input', (e) => {
                        document.getElementById('sensitivityValue').textContent = parseFloat(e.target.value).toFixed(1);
                    });
                }
            }

            setupCanvas() {
                const widthInput = document.getElementById('canvasWidth');
                const heightInput = document.getElementById('canvasHeight');
                const backgroundInput = document.getElementById('backgroundColor');
                
                const width = parseInt(widthInput?.value || '800');
                const height = parseInt(heightInput?.value || '200');
                const backgroundColor = backgroundInput?.value || '#000000';
                
                this.canvas.width = width;
                this.canvas.height = height;
                this.canvas.style.maxWidth = '100%';
                
                this.ctx.fillStyle = backgroundColor;
                this.ctx.fillRect(0, 0, width, height);
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadSection').classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadSection').classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadSection').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.loadAudioFile(files[0]);
                }
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.loadAudioFile(file);
                }
            }

            async loadAudioFile(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    this.setupAnalyser();
                    this.setupUI();
                    
                    document.getElementById('canvasContainer').style.display = 'block';
                    document.getElementById('exportSection').style.display = 'block';
                    
                    // Update duration
                    const duration = this.audioBuffer.duration;
                    document.getElementById('duration').textContent = this.formatTime(duration);
                    
                    this.enableControls();
                    
                } catch (error) {
                    alert('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ: ' + error.message);
                }
            }

            setupAnalyser() {
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                this.bufferLength = this.analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(this.bufferLength);
            }

            setupUI() {
                this.setupCanvas();
            }

            enableControls() {
                document.getElementById('playBtn').disabled = false;
                document.getElementById('generateBtn').disabled = false;
            }

            async play() {
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                this.source = this.audioContext.createBufferSource();
                this.source.buffer = this.audioBuffer;
                this.source.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);

                const currentTime = this.pauseTime || 0;
                this.source.start(0, currentTime);
                this.startTime = this.audioContext.currentTime - currentTime;
                this.isPlaying = true;

                document.getElementById('playBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;

                this.animate();

                this.source.onended = () => {
                    this.stop();
                };
            }

            pause() {
                if (this.source) {
                    this.source.stop();
                }
                this.pauseTime = this.audioContext.currentTime - this.startTime;
                this.isPlaying = false;
                cancelAnimationFrame(this.animationId);

                document.getElementById('playBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            }

            stop() {
                if (this.source) {
                    this.source.stop();
                }
                this.isPlaying = false;
                this.pauseTime = 0;
                cancelAnimationFrame(this.animationId);

                document.getElementById('playBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;

                // Reset progress
                document.getElementById('progressFill').style.width = '0%';
                document.getElementById('currentTime').textContent = '0:00';

                this.setupCanvas();
            }

            animate() {
                this.animationId = requestAnimationFrame(this.animate.bind(this));
                this.animationTime += 0.016; // Roughly 60fps

                this.analyser.getByteFrequencyData(this.dataArray);

                const width = this.canvas.width;
                const height = this.canvas.height;
                const backgroundColor = document.getElementById('backgroundColor')?.value || '#000000';
                const waveformColor = document.getElementById('waveformColor')?.value || '#00ff88';
                const barWidth = parseInt(document.getElementById('barWidth')?.value || '6');
                const barCount = parseInt(document.getElementById('barCount')?.value || '15');
                const barSpacing = parseInt(document.getElementById('barSpacing')?.value || '3');
                const sensitivity = parseFloat(document.getElementById('sensitivity')?.value || '1');
                const animationSpeed = parseFloat(document.getElementById('animationSpeed')?.value || '1');
                const smoothness = parseFloat(document.getElementById('smoothness')?.value || '0.3');

                // Clear canvas
                this.ctx.fillStyle = backgroundColor;
                this.ctx.fillRect(0, 0, width, height);

                // Calculate total width needed for bars
                const totalBarWidth = barCount * barWidth + (barCount - 1) * barSpacing;
                const startX = (width - totalBarWidth) / 2;

                // Set bar style
                this.ctx.fillStyle = waveformColor;

                // Initialize previous heights array if needed
                if (this.previousBarHeights.length !== barCount) {
                    this.previousBarHeights = new Array(barCount).fill(height * 0.2);
                }

                // Draw centered bars with smooth animation
                for (let i = 0; i < barCount; i++) {
                    // Calculate position from center
                    const centerIndex = Math.floor(barCount / 2);
                    const distanceFromCenter = Math.abs(i - centerIndex);
                    
                    // Create unique wave patterns for each bar
                    const waveOffset = i * 0.8; // Different phase for each bar
                    const waveFreq = 0.5 + (i % 3) * 0.3; // Varying frequencies
                    
                    // Multiple wave layers for complexity
                    const wave1 = Math.sin((this.animationTime * animationSpeed * waveFreq) + waveOffset) * 0.4;
                    const wave2 = Math.sin((this.animationTime * animationSpeed * waveFreq * 1.7) + waveOffset + Math.PI/4) * 0.3;
                    const wave3 = Math.sin((this.animationTime * animationSpeed * waveFreq * 0.6) + waveOffset + Math.PI/2) * 0.3;
                    
                    // Combine waves
                    const combinedWave = (wave1 + wave2 + wave3) * 0.5 + 0.5;
                    
                    // Get audio data influence
                    const dataIndex = Math.floor((i / barCount) * this.bufferLength);
                    const audioInfluence = (this.dataArray[dataIndex] / 255) * 0.6;
                    
                    // Calculate target height
                    let targetHeight = (combinedWave + audioInfluence) * height * sensitivity * 0.6;
                    
                    // Apply center weighting
                    const centerWeight = 1 - (distanceFromCenter / centerIndex) * 0.4;
                    targetHeight *= centerWeight;
                    
                    // Ensure minimum and maximum heights
                    targetHeight = Math.max(height * 0.1, Math.min(targetHeight, height * 0.8));
                    
                    // Smooth interpolation to prevent jerky movement
                    const currentHeight = this.previousBarHeights[i];
                    const smoothedHeight = currentHeight + (targetHeight - currentHeight) * smoothness;
                    this.previousBarHeights[i] = smoothedHeight;
                    
                    // Calculate bar position
                    const x = startX + i * (barWidth + barSpacing);
                    const y = (height - smoothedHeight) / 2;
                    
                    // Draw bar with rounded corners
                    this.drawRoundedRect(x, y, barWidth, smoothedHeight, barWidth / 2);
                }

                // Update progress safely
                const progressFill = document.getElementById('progressFill');
                const currentTimeEl = document.getElementById('currentTime');
                
                if (this.audioContext && this.audioBuffer) {
                    const currentTime = this.audioContext.currentTime - this.startTime;
                    const progress = (currentTime / this.audioBuffer.duration) * 100;
                    
                    if (progressFill) {
                        progressFill.style.width = Math.min(progress, 100) + '%';
                    }
                    if (currentTimeEl) {
                        currentTimeEl.textContent = this.formatTime(currentTime);
                    }
                }
            }

            drawRoundedRect(x, y, width, height, radius) {
                this.ctx.beginPath();
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
                this.ctx.closePath();
                this.ctx.fill();
            }

            async generateAnimation() {
                const exportFormat = document.getElementById('exportFormat').value;
                const fps = parseInt(document.getElementById('exportFPS').value);
                
                document.getElementById('generateBtn').disabled = true;
                document.getElementById('exportBtn').disabled = false;
                
                alert('Animation ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß! ‡∏Ñ‡∏•‡∏¥‡∏Å "‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î');
                
                document.getElementById('generateBtn').disabled = false;
            }

            async exportAnimation() {
                const format = document.getElementById('exportFormat').value;
                const fps = parseInt(document.getElementById('exportFPS').value);
                
                document.getElementById('exportBtn').disabled = true;
                document.getElementById('exportProgress').style.display = 'block';
                document.getElementById('exportStatus').textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå...';

                try {
                    if (format === 'webm') {
                        await this.exportAsVideo(fps);
                    } else {
                        await this.exportAsGIF(fps);
                    }
                } catch (error) {
                    alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
                } finally {
                    document.getElementById('exportBtn').disabled = false;
                    document.getElementById('exportProgress').style.display = 'none';
                    document.getElementById('exportStatus').textContent = '';
                }
            }

            async exportAsVideo(fps) {
                const stream = this.canvas.captureStream(fps);
                this.mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm'
                });

                this.recordedChunks = [];
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.recordedChunks.push(event.data);
                    }
                };

                this.mediaRecorder.onstop = () => {
                    const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                    this.downloadFile(blob, 'waveform-animation.webm');
                };

                this.mediaRecorder.start();
                
                // Simulate the animation for recording
                await this.simulateAnimation();
                
                this.mediaRecorder.stop();
            }

            async exportAsGIF(fps) {
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö GIF ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á canvas frames
                const frames = [];
                const frameCount = Math.floor(this.audioBuffer.duration * fps);
                
                for (let i = 0; i < frameCount; i++) {
                    const progress = i / frameCount;
                    await this.renderFrame(progress);
                    
                    // Convert canvas to image data
                    const imageData = this.canvas.toDataURL('image/png');
                    frames.push(imageData);
                    
                    // Update progress
                    const exportProgress = (i / frameCount) * 100;
                    document.getElementById('exportProgressFill').style.width = exportProgress + '%';
                }

                // Create a simple animation file (placeholder - in real implementation you'd use a GIF library)
                const canvas = document.createElement('canvas');
                canvas.width = this.canvas.width;
                canvas.height = this.canvas.height;
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                
                this.downloadFile(blob, 'waveform-animation.png');
                alert('‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å GIF ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô PNG ‡πÅ‡∏ó‡∏ô');
            }

            async simulateAnimation() {
                return new Promise((resolve) => {
                    const duration = this.audioBuffer.duration * 1000; // Convert to milliseconds
                    const startTime = Date.now();
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = elapsed / duration;
                        
                        if (progress >= 1) {
                            resolve();
                            return;
                        }
                        
                        this.renderFrame(progress);
                        
                        // Update export progress
                        document.getElementById('exportProgressFill').style.width = (progress * 100) + '%';
                        
                        requestAnimationFrame(animate);
                    };
                    
                    animate();
                });
            }

            renderFrame(progress) {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const backgroundColor = document.getElementById('backgroundColor').value;
                const waveformColor = document.getElementById('waveformColor').value;
                const barWidth = parseInt(document.getElementById('barWidth').value);
                const barCount = parseInt(document.getElementById('barCount').value);
                const barSpacing = parseInt(document.getElementById('barSpacing').value);
                const sensitivity = parseFloat(document.getElementById('sensitivity').value);
                const animationSpeed = parseFloat(document.getElementById('animationSpeed').value);

                // Clear canvas
                this.ctx.fillStyle = backgroundColor;
                this.ctx.fillRect(0, 0, width, height);

                // Calculate total width needed for bars
                const totalBarWidth = barCount * barWidth + (barCount - 1) * barSpacing;
                const startX = (width - totalBarWidth) / 2;

                // Set bar style
                this.ctx.fillStyle = waveformColor;

                // Draw centered bars with unique wave patterns
                for (let i = 0; i < barCount; i++) {
                    // Calculate position from center
                    const centerIndex = Math.floor(barCount / 2);
                    const distanceFromCenter = Math.abs(i - centerIndex);
                    
                    // Create unique wave patterns for each bar
                    const waveOffset = i * 0.8;
                    const waveFreq = 0.5 + (i % 3) * 0.3;
                    const timeBase = progress * Math.PI * 4 * animationSpeed;
                    
                    // Multiple wave layers
                    const wave1 = Math.sin(timeBase * waveFreq + waveOffset) * 0.4;
                    const wave2 = Math.sin(timeBase * waveFreq * 1.7 + waveOffset + Math.PI/4) * 0.3;
                    const wave3 = Math.sin(timeBase * waveFreq * 0.6 + waveOffset + Math.PI/2) * 0.3;
                    
                    const combinedWave = (wave1 + wave2 + wave3) * 0.5 + 0.5;
                    
                    let barHeight = combinedWave * height * sensitivity * 0.6;
                    
                    // Apply center weighting
                    const centerWeight = 1 - (distanceFromCenter / centerIndex) * 0.4;
                    barHeight *= centerWeight;
                    
                    // Ensure minimum and maximum heights
                    barHeight = Math.max(height * 0.1, Math.min(barHeight, height * 0.8));
                    
                    // Calculate bar position
                    const x = startX + i * (barWidth + barSpacing);
                    const y = (height - barHeight) / 2;
                    
                    // Draw bar with rounded corners
                    this.drawRoundedRect(x, y, barWidth, barHeight, barWidth / 2);
                }
            }

            downloadFile(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                document.getElementById('exportStatus').textContent = '‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!';
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new WaveformAnimator();
        });
    </script>
</body>
</html>